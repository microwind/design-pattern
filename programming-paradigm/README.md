# 编程范式概述
编程范式是指编程中的基本风格或模式，它定义了如何组织和表达计算过程。不同的编程范式具有不同的理念和特点，不同的语言有适合自己风格的方式，在面对不同场景时也可以选择不同的编程范式。

# 编程范式分类
- [面向过程编程(Procedural Programming, PP)](./procedural-programming)
  是一种基于过程（也称为函数、子程序或方法）的编程范式。在面向过程编程中，程序被分解为一系列的过程，每个过程执行特定的任务。这些过程通常按照顺序执行，直接操作程序的状态和数据。
  ```text
  +-------------------+
  |    Procedure 1    |
  +-------------------+
            |
            v
  +-------------------+
  |    Procedure 2    |
  +-------------------+
            |
            v
  +-------------------+
  |    Procedure 3    |
  +-------------------+
  ```


- [面向对象编程(Object-Oriented Programming, OOP)](./object-oriented-programming)
  将程序中的各种功能和数据封装成对象，通过类与对象之间的关系来组织和管理代码。OOP 提倡使用封装、继承和多态等特性，以提高代码的重用性和可维护性。

  ```text
  +-------------------+
  |       Class       |
  |  (Attributes, Methods) |
  +-------------------+
            |
            |  (Inheritance, Polymorphism)
            v
  +-------------------+
  |    Sub - Class     |
  |  (Extended Attributes, Methods) |
  +-------------------+
  ```

  包括：[接口](./object-oriented-programming/interface/) [抽象](./object-oriented-programming/abstraction/) [封装](./object-oriented-programming/encapsulation/) [继承](./object-oriented-programming/inheritance/) [多态](./object-oriented-programming/polymorphism/) [组合](./object-oriented-programming/composition/) [聚合](./object-oriented-programming/aggregation/)

- [函数式编程(Functional programming, FP)](./functional-programming)
  将计算视为数学函数的求值过程，避免使用状态和可变数据，强调函数的纯粹性和不可变性。函数式编程语言通常支持高阶函数、匿名函数和不可变数据结构等特性，比如Erlang、clojure、Scala、F#，以及流行的Python、Ruby、Javascript等。
  ```text
  +-------------------+
  |      Function     |
  |  (Input -> Output) |
  +-------------------+
            |
            |  (Function Composition)
            v
  +-------------------+
  |  Composed Function |
  |  (Combined Input -> Output) |
  +-------------------+
  ```

- [面向切面编程(Aspect-Oriented Programming, AOP)](./aspect-oriented-programming)
  AOP 的核心思想是将横切关注点（Cross-Cutting Concerns）从核心业务逻辑中分离出来，动态地将代码切入到类的指定方法、指定位置上，以便统一管理和处理，旨在提高软件系统的模块化和可维护性。
  ```text
  +-------------------+
  |    Core Business   |
  |      Logic         |
  +-------------------+
            |
            |  (横切关注点)
            v
  +-------------------+
  |    Aspect         |
  |  (Logging, Security, etc.) |
  +-------------------+
  ```

- [事件驱动编程(Event-Driven Programming, EDP)](./event-driven-programming)
  基于事件的发生和处理来组织程序逻辑，程序的执行流程是由事件的发生和相应的处理程序来驱动的。事件驱动编程的核心是事件循环。
  ```text
  +-------------------+
  |    Event Source   |
  |  (User actions, System events) |
  +-------------------+
            |
            |  (Event)
            v
  +-------------------+
  |   Event Handler   |
  |  (Logic to execute) |
  +-------------------+
  ```

- [响应式编程(Reactive Programming, RP)](./reactive-programming)
  通过使用异步数据流和函数式编程的思想，以响应事件和数据变化为中心，构建具有高度交互性和实时性的应用程序。响应式编程关注数据流的变化和处理方式，以提高代码的灵活性和响应性。
  ```text
  +-------------------+
  |    Data Source    |
  |  (Events, Streams) |
  +-------------------+
            |
            |  (Observable)
            v
  +-------------------+
  |   Subscriber      |
  |  (Reacts to Changes) |
  +-------------------+
  ```

## 编程范式对比
| 对比维度       | 面向对象编程（OOP）                                                                                                                                                                                                 | 函数式编程（FP）                                                                                                                                                                                                 | 面向切面编程（AOP）                                                                                                                                                                                                 | 面向过程编程（PP）                                                                                                                                                                                                 | 响应式编程（RP）                                                                                                                                                                                                 | 事件驱动编程（EDP）                                                                                                                                                                                                 |
|----------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **设计模式**   | - **单例模式**：确保一个类只有一个实例，并提供全局访问点。常用于配置管理类。<br>- **工厂模式**：定义一个创建对象的接口，让子类决定实例化哪个类。例如创建不同类型的数据库连接。<br>- **观察者模式**：对象间存在一对多的依赖关系，当一个对象状态改变时，所有依赖它的对象都会得到通知并自动更新。常用于事件处理。 | - **高阶函数**：将函数作为参数传递或返回函数，实现代码复用和灵活组合。如 `map`、`filter` 等函数。<br>- **柯里化**：将多参数函数转换为一系列单参数函数，方便函数复用和延迟计算。                                                                 | - **切面模式**：定义切面类，封装横切关注点的逻辑，并在合适的切入点进行织入。例如日志记录切面、事务管理切面。                                                                                                         | - **顺序模式**：按照步骤依次执行函数，完成特定任务。如简单的数学计算程序。<br>- **模块化模式**：将程序分解为多个模块，每个模块负责特定功能，提高代码可维护性。                                                       | - **数据流模式**：通过创建和操作数据流来处理异步事件和数据变化。如使用 RxJS 的 `Observable` 和 `Subject`。<br>- **背压模式**：处理生产者和消费者之间速度不匹配的问题，避免数据积压。                                 | - **事件监听器模式**：定义事件源和事件监听器，当事件发生时，通知相应的监听器执行处理逻辑。如 GUI 中的按钮点击事件监听。<br>- **发布-订阅模式**：事件发布者将事件发布到事件通道，订阅者从通道中订阅感兴趣的事件并处理。 |
| **分层架构**   | - **表现层**：负责与用户交互，展示数据和接收用户输入，如 Web 应用的前端页面。<br>- **业务逻辑层**：处理业务规则和业务流程，调用数据访问层获取和处理数据。<br>- **数据访问层**：负责与数据库或其他数据源交互，进行数据的增删改查操作。                                               | - **数据处理层**：专注于数据的转换、过滤和计算，使用纯函数进行操作。<br>- **控制层**：负责协调不同的数据处理函数，实现业务逻辑。<br>- **接口层**：提供对外的接口，方便与其他系统或模块进行交互。                                               | - **核心业务层**：包含核心的业务逻辑，不包含横切关注点。<br>- **切面层**：封装横切关注点的逻辑，如日志、事务等。<br>- **织入层**：负责将切面逻辑织入到核心业务逻辑中。                                               | - **输入层**：接收用户输入或外部数据。<br>- **处理层**：对输入数据进行处理，调用相应的函数完成任务。<br>- **输出层**：将处理结果输出给用户或存储到外部系统。                                                         | - **数据源层**：提供数据流的来源，如网络请求、传感器数据等。<br>- **操作层**：对数据流进行操作，如映射、过滤、合并等。<br>- **订阅层**：订阅数据流并处理数据变化，更新界面或执行其他操作。                             | - **事件源层**：产生各种事件，如用户操作、系统消息等。<br>- **事件处理层**：定义事件处理逻辑，根据不同的事件类型执行相应的操作。<br>- **事件调度层**：负责事件的分发和调度，将事件发送给合适的处理程序。                 |
| **编程范式特点** | - 以对象为中心，将数据和操作封装在类中，通过继承、多态和封装实现代码复用和扩展。<br>- 强调对象之间的交互和协作，模拟现实世界的对象关系。                                                                           | - 强调函数的纯粹性，避免共享状态和可变数据，函数的输出仅取决于输入。<br>- 通过函数的组合和高阶函数构建复杂程序，提高代码的可预测性和可维护性。                                                                 | - 关注横切关注点的分离，将跨越多个模块的功能（如日志、事务）从核心业务逻辑中分离出来。<br>- 通过切面和切入点的定义，在运行时将横切逻辑织入到核心业务逻辑中。                                                         | - 按照步骤和顺序组织程序逻辑，将大问题分解为子步骤，每个子步骤由函数实现。<br>- 程序执行流程是顺序执行各个函数，逻辑直接清晰。                                                                                       | - 基于异步数据流，利用观察者模式和流的概念，使程序能自动响应数据变化。<br>- 处理异步和事件驱动的场景，简化异步编程。                                                                                                   | - 程序执行流程由事件触发决定，通过监听事件，在事件发生时执行相应的处理逻辑。<br>- 适用于交互式系统和需要及时响应事件的场景。                                                                                           |
| **优点**       | - 代码结构清晰，符合人类思维习惯，便于维护和扩展。<br>- 通过继承和多态减少代码重复，提高代码复用性。                                                                                                               | - 函数的纯粹性使代码易于测试和调试，不可变数据避免副作用，提高代码稳定性。<br>- 便于并行计算和处理并发问题。                                                                                                   | - 分离横切关注点，提高代码模块化和可维护性，减少代码重复。<br>- 可在不修改核心业务逻辑的情况下添加额外功能。                                                                                                         | - 逻辑简单直接，执行效率高，适用于简单顺序任务。<br>- 易于理解和实现，代码可读性高。                                                                                                                               | - 简化异步编程，提高代码可读性和可维护性，更好地处理并发和事件流。<br>- 能自动响应数据变化，适用于实时数据处理。                                                                                                       | - 程序可根据事件灵活执行，提高用户体验和系统响应性。<br>- 模块间耦合度低，便于开发和维护。                                                                                                                           |
| **缺点**       | - 类的层次结构可能复杂，导致代码理解和维护难度增加。<br>- 过度设计可能带来性能开销。                                                                                                                               | - 学习曲线较陡，对于习惯命令式编程的开发者较难理解。<br>- 某些复杂计算可能需要更多代码实现。                                                                                                                   | - 引入额外复杂性，影响代码可读性，织入过程可能有性能开销。<br>- 调试时需同时考虑核心业务和切面逻辑。                                                                                                               | - 代码复用性差，可维护性和扩展性低，大型程序难管理。<br>- 缺乏数据和操作的封装，安全性和可维护性受影响。                                                                                                             | - 学习曲线陡，理解和调试异步数据流困难。<br>- 引入一定性能开销。                                                                                                                                                     | - 事件处理逻辑分散，代码可读性和可维护性可能降低。<br>- 调试复杂，尤其是多个事件相互影响时。                                                                                                                         |
| **应用场景**   | - 游戏开发、图形界面设计、大型软件系统等，模拟现实世界对象关系。                                                                                                                                                   | - 数据处理、并发编程、人工智能等，处理大量数据和并行计算。                                                                                                                                                   | - 日志记录、事务管理、安全性检查等，处理跨越多个模块的横切关注点。                                                                                                                                                 | - 小型程序、脚本、嵌入式系统等，处理简单顺序任务。                                                                                                                                                                   | - 实时数据处理、用户界面更新、异步任务处理等，处理异步数据流。                                                                                                                                                       | - 图形用户界面（GUI）、游戏开发、网络服务器等，处理用户交互和事件驱动任务。|

# 本文链接
https://github.com/microwind/design-patterns/tree/main/programming-paradigm